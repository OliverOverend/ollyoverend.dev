{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"404/","title":"404 - Page Not Found","text":"<p>The page you're looking for doesn't exist or has been moved.</p> <p>Go back home</p>"},{"location":"blog/tags/","title":"Tags","text":""},{"location":"blog/tags/#tag:articles","title":"articles","text":"<ul> <li>            Recently Read          </li> </ul>"},{"location":"blog/tags/#tag:best-practices","title":"best-practices","text":"<ul> <li>            Managing Python Dependencies          </li> </ul>"},{"location":"blog/tags/#tag:books","title":"books","text":"<ul> <li>            Recently Read          </li> </ul>"},{"location":"blog/tags/#tag:data-processing","title":"data-processing","text":"<ul> <li>            Keeping First Occurrences in NumPy Arrays          </li> </ul>"},{"location":"blog/tags/#tag:dependencies","title":"dependencies","text":"<ul> <li>            Managing Python Dependencies          </li> </ul>"},{"location":"blog/tags/#tag:numpy","title":"numpy","text":"<ul> <li>            Keeping First Occurrences in NumPy Arrays          </li> </ul>"},{"location":"blog/tags/#tag:packaging","title":"packaging","text":"<ul> <li>            Managing Python Dependencies          </li> </ul>"},{"location":"blog/tags/#tag:performance","title":"performance","text":"<ul> <li>            Keeping First Occurrences in NumPy Arrays          </li> </ul>"},{"location":"blog/tags/#tag:software-engineering","title":"software-engineering","text":"<ul> <li>            Recently Read          </li> </ul>"},{"location":"blog/2025/06/21/managing-python-dependencies/","title":"Managing Python Dependencies","text":"<p>Python packages often rely on a complex network of other packages to function. When publishing a Python package, it's essential to define which dependencies are required and to specify the range of compatible versions. However, the approach you take depends critically on whether you're building an application or a library.</p> <p>Understanding this distinction is key to avoiding dependency conflicts and ensuring your package works well in the broader Python ecosystem.</p>","tags":["dependencies","packaging","best-practices"]},{"location":"blog/2025/06/21/managing-python-dependencies/#application","title":"Application","text":"<p>An application is a Python package designed to be executed directly by users or deployed as a standalone service. Examples include web applications (Django/Flask apps), CLI tools, data pipelines, or microservices. There is typically no requirement for an application to be compatible with other libraries in a shared environment.</p>","tags":["dependencies","packaging","best-practices"]},{"location":"blog/2025/06/21/managing-python-dependencies/#best-practices-for-applications","title":"Best Practices for Applications","text":"<p>Pin all dependencies and sub-dependencies using a lockfile to ensure reproducibility across development, testing, and production environments.</p> <p>Common lockfile formats:</p> <ul> <li><code>requirements.txt</code> with <code>pip freeze</code></li> <li><code>poetry.lock</code> with Poetry</li> <li><code>Pipfile.lock</code> with Pipenv</li> <li><code>pdm.lock</code> with PDM</li> </ul> <p>Example: A Django web application should pin exact versions like <code>Django==4.2.7</code> to ensure the same version runs in all environments, preventing unexpected breakage from dependency updates.</p>","tags":["dependencies","packaging","best-practices"]},{"location":"blog/2025/06/21/managing-python-dependencies/#library","title":"Library","text":"<p>A library is a Python package designed to be used alongside other libraries within a shared environment. Examples include <code>requests</code>, <code>pandas</code>, or any package published to PyPI that other developers will import. Unlike applications, avoid pinning exact dependency versions to prevent conflicts when other libraries require different versions of the same dependency.</p>","tags":["dependencies","packaging","best-practices"]},{"location":"blog/2025/06/21/managing-python-dependencies/#best-practices-for-libraries","title":"Best Practices for Libraries","text":"<p>Use flexible version constraints that allow your library to coexist with others:</p>","tags":["dependencies","packaging","best-practices"]},{"location":"blog/2025/06/21/managing-python-dependencies/#set-a-strict-lower-bound","title":"Set a Strict Lower Bound","text":"<p>Require versions that include critical features or fixes your library depends on. This encourages users to adopt more recent, stable versions.</p> <p>Example: If your library uses f-strings (added in Python 3.6) and a feature from <code>requests</code> 2.25.0:</p> <pre><code># setup.py or pyproject.toml\ndependencies = [\n    \"requests&gt;=2.25.0\",\n]\n</code></pre>","tags":["dependencies","packaging","best-practices"]},{"location":"blog/2025/06/21/managing-python-dependencies/#avoid-upper-bounds-unless-necessary","title":"Avoid Upper Bounds Unless Necessary","text":"<p>Overly restrictive upper bounds (like <code>requests&gt;=2.25.0,&lt;3.0.0</code>) can break compatibility when other libraries require newer versions. This creates dependency conflicts that prevent users from installing your library alongside others.</p> <p>When upper bounds are justified:</p> <ul> <li>A known version is broken or has a critical bug affecting your library</li> <li>An upcoming major release introduces confirmed breaking changes</li> <li>You need time to test compatibility with a new major version</li> </ul> <p>Important: Remove upper bounds quickly once compatibility is restored or verified. Consider using tools like <code>dependabot</code> to stay informed about new releases.</p>","tags":["dependencies","packaging","best-practices"]},{"location":"blog/2025/06/21/managing-python-dependencies/#quick-reference","title":"Quick Reference","text":"Aspect Application Library Purpose Standalone executable Imported by other code Version Pinning Pin exact versions (<code>==</code>) Use flexible bounds (<code>&gt;=</code>) Lockfiles Required (commit to repo) Not used for distribution Upper Bounds Not a concern Avoid unless necessary Examples Web apps, CLI tools, services <code>requests</code>, <code>pandas</code>, utilities","tags":["dependencies","packaging","best-practices"]},{"location":"blog/2025/06/21/managing-python-dependencies/#further-reading","title":"Further Reading","text":"<ul> <li>Should You Use Upper Bound Version Constraints?</li> <li>Setup vs. Requirements</li> </ul>","tags":["dependencies","packaging","best-practices"]},{"location":"blog/2025/06/20/recently-read/","title":"Recently Read","text":"<p>I like to keep track of interesting technical content I come across. Here are some articles and books I've recently read that have influenced my thinking about software development.</p>","tags":["books","articles","software-engineering"]},{"location":"blog/2025/06/20/recently-read/#articles","title":"Articles","text":"","tags":["books","articles","software-engineering"]},{"location":"blog/2025/06/20/recently-read/#design-docs-at-google","title":"Design Docs at Google","text":"<p>An insightful look into how Google uses design documents to facilitate better engineering decisions. The article explores the structure, purpose, and collaborative nature of design docs, highlighting how they help teams align on technical approaches before implementation. Key takeaways include the importance of documenting trade-offs and getting early feedback from stakeholders.</p>","tags":["books","articles","software-engineering"]},{"location":"blog/2025/06/20/recently-read/#books","title":"Books","text":"","tags":["books","articles","software-engineering"]},{"location":"blog/2025/06/20/recently-read/#the-pragmatic-programmer-20th-anniversary-edition","title":"The Pragmatic Programmer (20th Anniversary Edition)","text":"<p>A timeless classic that has been updated for the modern era. This book covers fundamental principles of software craftsmanship, from writing flexible code to avoiding technical debt. The pragmatic approach emphasizes practical techniques that can be applied immediately, making it essential reading for developers at any stage of their career.</p>","tags":["books","articles","software-engineering"]},{"location":"blog/2025/06/21/keeping-first-occurrences-in-numpy-arrays/","title":"Keeping First Occurrences in NumPy Arrays","text":"<p>When working with data in NumPy, you often encounter duplicate values that need to be filtered. A common requirement is to keep only the first occurrence of each value while preserving the original order. This is particularly useful when processing time-series data, removing duplicate measurements, or deduplicating event logs.</p>","tags":["numpy","data-processing","performance"]},{"location":"blog/2025/06/21/keeping-first-occurrences-in-numpy-arrays/#the-problem","title":"The Problem","text":"<p>Given an array with duplicate values, we want to:</p> <ol> <li>Identify which elements are duplicates</li> <li>Keep only the first occurrence of each value</li> <li>Preserve the original order</li> </ol> <p>For example, transforming <code>[1, 2, 3, 2, 1, 4]</code> into <code>[1, 2, 3, 4]</code>.</p>","tags":["numpy","data-processing","performance"]},{"location":"blog/2025/06/21/keeping-first-occurrences-in-numpy-arrays/#the-solution","title":"The Solution","text":"<p>NumPy provides an efficient way to solve this using <code>np.unique()</code> with the <code>return_index</code> parameter:</p> <pre><code>import numpy as np\n\ndef keep_first_occurrence(arr):\n    \"\"\"\n    Keep only the first occurrence of each value in the array.\n\n    Parameters\n    ----------\n    arr : np.ndarray\n        Input array with potential duplicates\n\n    Returns\n    -------\n    np.ndarray\n        Array with duplicates removed, preserving order\n    \"\"\"\n    _, unique_indices = np.unique(arr, return_index=True)\n    # Sort indices to preserve original order\n    return arr[np.sort(unique_indices)]\n\n\n# Example usage\ndata = np.array([1, 2, 3, 2, 1, 4])\nresult = keep_first_occurrence(data)\nprint(result)  # Output: [1 2 3 4]\n</code></pre>","tags":["numpy","data-processing","performance"]},{"location":"blog/2025/06/21/keeping-first-occurrences-in-numpy-arrays/#how-it-works","title":"How It Works","text":"<ol> <li><code>np.unique(arr, return_index=True)</code> returns both unique values and their first occurrence indices</li> <li>We sort these indices to maintain the original order</li> <li>We use fancy indexing to extract elements at those positions</li> </ol>","tags":["numpy","data-processing","performance"]},{"location":"blog/2025/06/21/keeping-first-occurrences-in-numpy-arrays/#performance-considerations","title":"Performance Considerations","text":"<p>This approach is efficient for NumPy arrays because it leverages vectorized operations. For very large datasets, this method scales well with O(n log n) complexity due to the sorting step.</p> <p>For pure Python lists, consider using a different approach:</p> <pre><code>def keep_first_occurrence_list(lst):\n    \"\"\"Python list version using dict to preserve order.\"\"\"\n    return list(dict.fromkeys(lst))\n</code></pre> <p>The dict-based approach works because Python 3.7+ dictionaries maintain insertion order, making this a clean one-liner for lists.</p>","tags":["numpy","data-processing","performance"]},{"location":"blog/archive/2025/","title":"June 2025","text":""},{"location":"blog/category/python/","title":"Python","text":""},{"location":"blog/category/reading/","title":"Reading","text":""}]}